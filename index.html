<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Couple's Trivia Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* General Styling */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f06d6d, #f9a8d4); /* Soft gradient background */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling for smaller screens */
        }

        .container {
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 40px;
            width: 100%;
            max-width: 700px;
            text-align: center;
            animation: fadeIn 0.8s ease-out;
            position: relative; /* For loading overlay */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            color: #e91e63; /* Pink heading */
            margin-bottom: 20px;
            font-size: 2.5em;
            font-weight: 700;
        }

        h2 {
            color: #d81b60; /* Darker pink for subheadings */
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        p {
            margin-bottom: 15px;
            line-height: 1.6;
        }

        input[type="text"] {
            width: calc(100% - 20px);
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #ffccd5; /* Light pink border */
            border-radius: 10px;
            font-size: 1.1em;
            outline: none;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus {
            border-color: #e91e63; /* Pink on focus */
        }

        button {
            background-color: #e91e63; /* Pink button */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px rgba(233, 30, 99, 0.3);
            margin: 5px;
            font-weight: 600;
        }

        button:hover {
            background-color: #d81b60; /* Darker pink on hover */
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(233, 30, 99, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(233, 30, 99, 0.2);
        }

        button:disabled {
            background-color: #ffccd5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px dashed #ffccd5; /* Dashed separator */
        }

        .game-info {
            background-color: #fff0f5; /* Light pink background */
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #d81b60;
            font-weight: 600;
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            margin-bottom: 30px;
            font-size: 1.3em;
            font-weight: 700;
            color: #e91e63;
        }

        .score-board div {
            padding: 10px 20px;
            background-color: #ffebee; /* Very light pink */
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .question-area {
            background-color: #fce4ec; /* Lighter pink */
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            font-weight: 600;
            color: #880e4f; /* Darkest pink for question */
            text-align: center;
        }

        .answers-display {
            margin-top: 20px;
            padding: 15px;
            background-color: #f3e5f5; /* Light purple-pink */
            border-radius: 10px;
            text-align: left;
            font-size: 1.1em;
            color: #4a148c; /* Dark purple for answers */
        }

        .answers-display div {
            margin-bottom: 10px;
        }

        .message-box {
            background-color: #fff3e0; /* Light orange-pink */
            color: #ff5722; /* Orange for messages */
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-weight: 600;
            display: none; /* Hidden by default */
        }

        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 20px;
            z-index: 10;
            transition: opacity 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #e91e63;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Game Over Screen */
        #gameOverScreen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
            background-color: #fce4ec;
            border-radius: 15px;
            margin-top: 20px;
        }

        #gameOverScreen h2 {
            font-size: 2.2em;
            color: #880e4f;
            margin-bottom: 15px;
        }

        #gameOverScreen p {
            font-size: 1.3em;
            font-weight: 600;
            color: #d81b60;
            margin-bottom: 25px;
        }

        /* Confetti Canvas */
        #confettiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 9; /* Below loading overlay, above other content */
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 25px;
            }
            h1 {
                font-size: 2em;
            }
            h2 {
                font-size: 1.5em;
            }
            .question-area {
                font-size: 1.2em;
                padding: 20px;
            }
            .score-board {
                flex-direction: column;
                gap: 10px;
            }
            .score-board div {
                width: 80%;
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="confettiCanvas"></canvas>
        <div class="loading-overlay" id="loadingOverlay">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">Loading...</div>
        </div>

        <h1>ðŸ’– Brew-Studios Presents: Couple's Trivia ðŸ’–</h1>
        <p>A fun game for you and your partner!</p>

        <div id="authSection">
            <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
            <button id="startGameButton">Start Game</button>
        </div>

        <div id="gameLobby" style="display: none;">
            <div class="game-info">
                <p>Your User ID: <span id="myUserId"></span></p>
                <p>Status: <span id="gameStatus">Connecting...</span></p>
            </div>

            <h2>Create or Join a Game</h2>
            <button id="createGameButton">Create New Game</button>
            <div class="section">
                <input type="text" id="joinGameIdInput" placeholder="Enter partner's User ID to join">
                <button id="joinGameButton">Join Game</button>
            </div>
        </div>

        <div id="gamePlayArea" style="display: none;">
            <div class="score-board">
                <div><span id="player1NameDisplay">Player 1</span>: <span id="player1ScoreDisplay">0</span></div>
                <div><span id="player2NameDisplay">Player 2</span>: <span id="player2ScoreDisplay">0</span></div>
            </div>

            <div class="question-area" id="questionDisplay">Waiting for game to start...</div>

            <div id="answerInputSection">
                <input type="text" id="answerInput" placeholder="Type your answer here..." maxlength="100">
                <button id="submitAnswerButton">Submit Answer</button>
            </div>

            <!-- Moved nextQuestionButton out of revealedAnswers for independent control -->
            <button id="nextQuestionButton" style="margin-top: 15px; display: none;">Next Question</button>

            <div class="answers-display" id="revealedAnswers" style="display: none;">
                <h3>Answers:</h3>
                <div id="player1AnswerDisplay"></div>
                <div id="player2AnswerDisplay"></div>
                <!-- The nextQuestionButton was here, now it's outside -->
            </div>

            <div class="message-box" id="messageBox"></div>

            <button id="leaveGameButton" style="margin-top: 30px;">Leave Game</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" style="display: none;">
            <h2>Game Over!</h2>
            <p id="finalScores"></p>
            <button id="playAgainButton">Play Again</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, addDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase instances
        let app;
        let db;
        let auth;
        let userId = null;
        let playerName = "Guest";
        let gameId = null; // The ID of the current game room
        let unsubscribeGameListener = null; // To stop listening to game updates
        let currentQuestionCount = 0; // Tracks number of questions asked in current game
        const maxQuestions = 10; // Max questions per game for dynamic generation
        let appId = null; // Declare appId globally to be set from firebaseConfig

        // Gemini API Key (empty string for Canvas runtime injection)
        const GEMINI_API_KEY = ""; 
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;


        // Get elements
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const authSection = document.getElementById('authSection');
        const playerNameInput = document.getElementById('playerNameInput');
        const startGameButton = document.getElementById('startGameButton');
        const gameLobby = document.getElementById('gameLobby');
        const myUserIdSpan = document.getElementById('myUserId');
        const gameStatusSpan = document.getElementById('gameStatus');
        const createGameButton = document.getElementById('createGameButton');
        const joinGameIdInput = document.getElementById('joinGameIdInput');
        const joinGameButton = document.getElementById('joinGameButton');
        const gamePlayArea = document.getElementById('gamePlayArea');
        const player1NameDisplay = document.getElementById('player1NameDisplay');
        const player2NameDisplay = document.getElementById('player2NameDisplay'); 
        const player1ScoreDisplay = document.getElementById('player1ScoreDisplay');
        const player2ScoreDisplay = document.getElementById('player2ScoreDisplay');
        const questionDisplay = document.getElementById('questionDisplay');
        const answerInputSection = document.getElementById('answerInputSection');
        const answerInput = document.getElementById('answerInput');
        const submitAnswerButton = document.getElementById('submitAnswerButton');
        const revealedAnswers = document.getElementById('revealedAnswers');
        const player1AnswerDisplay = document.getElementById('player1AnswerDisplay');
        const player2AnswerDisplay = document.getElementById('player2AnswerDisplay');
        const nextQuestionButton = document.getElementById('nextQuestionButton');
        const messageBox = document.getElementById('messageBox');
        const leaveGameButton = document.getElementById('leaveGameButton');
        const gameOverScreen = document.getElementById('gameOverScreen'); // New element
        const finalScoresDisplay = document.getElementById('finalScores'); // New element
        const playAgainButton = document.getElementById('playAgainButton'); // New element

        // Confetti Canvas elements
        const confettiCanvas = document.getElementById('confettiCanvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiParticles = [];
        const maxConfetti = 100; // Max number of confetti particles

        /**
         * Confetti particle class.
         */
        class ConfettiParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 10 + 5;
                this.color = color;
                this.speedX = Math.random() * 6 - 3;
                this.speedY = Math.random() * -10 - 5;
                this.gravity = 0.3;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = Math.random() * 10 - 5;
            }

            update() {
                this.speedY += this.gravity;
                this.x += this.speedX;
                this.y += this.speedY;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                confettiCtx.save();
                confettiCtx.translate(this.x, this.y);
                confettiCtx.rotate(this.rotation * Math.PI / 180);
                confettiCtx.fillStyle = this.color;
                confettiCtx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                confettiCtx.restore();
            }
        }

        /**
         * Emits confetti from a specific point.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} count - Number of particles.
         */
        function emitConfetti(x, y, count) {
            const colors = ['#f06d6d', '#f9a8d4', '#e91e63', '#d81b60', '#880e4f'];
            for (let i = 0; i < count; i++) {
                if (confettiParticles.length < maxConfetti) {
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    confettiParticles.push(new ConfettiParticle(x, y, color));
                }
            }
        }

        /**
         * Animates the confetti particles.
         */
        function animateConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            for (let i = confettiParticles.length - 1; i >= 0; i--) {
                const particle = confettiParticles[i];
                particle.update();
                particle.draw();

                // Remove particles that are off-screen
                if (particle.y > confettiCanvas.height || particle.x < 0 || particle.x > confettiCanvas.width) {
                    confettiParticles.splice(i, 1);
                }
            }
            requestAnimationFrame(animateConfetti);
        }

        /**
         * Resizes the confetti canvas to fill the window.
         */
        function resizeConfettiCanvas() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', 'info'.
         * @param {boolean} persistent - If true, message won't auto-hide.
         */
        function showMessage(message, type = 'info', persistent = false) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            messageBox.style.backgroundColor = ''; // Reset
            messageBox.style.color = ''; // Reset

            if (type === 'success') {
                messageBox.style.backgroundColor = '#e8f5e9';
                messageBox.style.color = '#2e7d32';
            } else if (type === 'error') {
                messageBox.style.backgroundColor = '#ffebee';
                messageBox.style.color = '#c62828';
            } else { // info
                messageBox.style.backgroundColor = '#e3f2fd';
                messageBox.style.color = '#1565c0';
            }

            if (!persistent) {
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, 5000);
            }
        }

        /**
         * Shows or hides the loading overlay.
         * @param {boolean} show - True to show, false to hide.
         * @param {string} text - Optional text to display.
         */
        function showLoading(show, text = 'Loading...') {
            loadingText.textContent = text;
            if (show) {
                loadingOverlay.classList.add('active');
            } else {
                loadingOverlay.classList.remove('active');
            }
        }

        /**
         * Initializes Firebase and authenticates the user.
         */
        async function initializeFirebase() {
            showLoading(true, 'Initializing game...');
            try {
                // Firebase configuration: IMPORTANT!
                // This object MUST contain the exact configuration for your Firebase project.
                // You can find this in your Firebase Console under Project settings > General > Your apps.
                //
                // Common causes for "auth/configuration-not-found" error:
                // 1. 'authDomain' in this firebaseConfig object is incorrect or misspelled.
                //    - Double-check your Firebase Project settings > General > Your apps > "Auth domain".
                //      It should match exactly (e.g., "your-project-id.firebaseapp.com").
                // 2. Firebase 'Authentication' service is NOT enabled in your Firebase project.
                //    - Go to Firebase Console > Authentication > "Get started" or "Enable".
                // 3. The 'Anonymous' sign-in method is NOT enabled under Authentication > Sign-in method.
                //    - Go to Firebase Console > Authentication > "Sign-in method" tab > "Anonymous" and enable it.
                const firebaseConfig = {
                    apiKey: "AIzaSyB4NYRePoxx7tHKV5AM_IHPQ75LFZQSOPw",
                    authDomain: "couple-s-trivia.firebaseapp.com",
                    projectId: "couple-s-trivia",
                    storageBucket: "couple-s-trivia.firebasestorage.app",
                    messagingSenderId: "262441038638",
                    appId: "1:262441038638:web:9a0c3fdd2b702ce0d680bf"
                };
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Assign the global appId from the initialized app's options
                // This ensures consistency when constructing Firestore paths.
                appId = app.options.appId; 

                console.log("Firebase Config Used:", firebaseConfig); // For debugging
                console.log("Derived App ID (for Firestore paths):", appId); // For debugging

                // Sign in anonymously for game functionality
                // This will create a temporary user for each player without requiring a login form.
                await signInAnonymously(auth);
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        myUserIdSpan.textContent = userId;
                        gameStatusSpan.textContent = "Ready to play!";
                        console.log("Firebase initialized. User ID:", userId);
                        showLoading(false);
                        // Show auth section first to get player name
                        authSection.style.display = 'block';
                    } else {
                        userId = null;
                        myUserIdSpan.textContent = 'N/A';
                        gameStatusSpan.textContent = "Not authenticated.";
                        console.log("User signed out or not authenticated.");
                        showLoading(false);
                        authSection.style.display = 'block';
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showMessage("Failed to initialize game. Please try again. Check console for details.", 'error');
                showLoading(false);
            }
        }

        /**
         * Generates a trivia question using the Gemini API.
         * @returns {Promise<string>} A promise that resolves with the generated question.
         */
        async function generateTriviaQuestion() {
            showLoading(true, 'Generating a new question...');
            try {
                const prompt = "Generate a single, fun, lighthearted trivia question for a couple's game. It should be a general knowledge question or a fun 'would you rather' type question, not something too personal or specific to a real couple. Keep it concise and engaging. Example: 'What is the capital of France?' or 'Would you rather have a pet dragon or a pet unicorn?'";
                
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    console.log("Generated Question:", text); // Log the generated question
                    showLoading(false);
                    return text;
                } else {
                    throw new Error("Invalid response structure from Gemini API.");
                }
            } catch (error) {
                console.error("Error generating question from Gemini API:", error);
                showMessage("Failed to generate question. Using a fallback question.", 'error');
                showLoading(false);
                // Fallback to a generic question if API fails
                return "What is your partner's favorite color?"; 
            }
        }

        /**
         * Sets up a real-time listener for the game document.
         * @param {string} id - The game ID.
         */
        function setupGameListener(id) {
            if (unsubscribeGameListener) {
                unsubscribeGameListener(); // Unsubscribe from previous listener if any
            }

            // Use the globally set appId for Firestore paths
            // Ensure 'app' is initialized before this function is called
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/coupleGames`, id);

            unsubscribeGameListener = onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();
                    console.log("Game data updated:", gameData);
                    updateGameUI(gameData);
                } else {
                    console.log("Game does not exist or was deleted.");
                    showMessage("The game you were in no longer exists.", 'error', true); // Persistent error
                    leaveGame(); // Automatically leave if game is deleted
                }
            }, (error) => {
                console.error("Error listening to game updates:", error);
                showMessage("Error receiving game updates. Please check your connection.", 'error', true); // Persistent error
            });
        }

        /**
         * Updates the UI based on the current game state.
         * @param {object} gameData - The current game data from Firestore.
         */
        function updateGameUI(gameData) {
            // Update player names and scores
            player1NameDisplay.textContent = gameData.player1Name || 'Player 1';
            player2NameDisplay.textContent = gameData.player2Name || 'Player 2';
            player1ScoreDisplay.textContent = gameData.player1Score || 0;
            player2ScoreDisplay.textContent = gameData.player2Score || 0;

            // Determine if current user is player 1 or player 2
            const isPlayer1 = userId === gameData.player1Id;
            const isPlayer2 = userId === gameData.player2Id;

            // Hide game over screen by default
            gameOverScreen.style.display = 'none';

            // Show game play area
            gameLobby.style.display = 'none';
            gamePlayArea.style.display = 'block';

            // Update game status message
            if (!gameData.player2Id) {
                gameStatusSpan.textContent = "Waiting for partner to join...";
                questionDisplay.textContent = "Share your User ID to your partner: " + gameId;
                answerInputSection.style.display = 'none';
                revealedAnswers.style.display = 'none';
                submitAnswerButton.disabled = true;
                nextQuestionButton.disabled = true;
                nextQuestionButton.style.display = 'none'; // Ensure it's hidden if waiting for partner
                return; // Wait until both players are connected
            } else {
                gameStatusSpan.textContent = "Game in progress!";
            }

            // Game state logic
            switch (gameData.state) {
                case 'waiting':
                    questionDisplay.textContent = "Waiting for game to start...";
                    answerInputSection.style.display = 'none';
                    revealedAnswers.style.display = 'none';
                    submitAnswerButton.disabled = true;
                    nextQuestionButton.disabled = true;

                    // If both players are present, player 1 can start the game
                    if (isPlayer1 && gameData.player2Id) {
                        questionDisplay.textContent = "Both players are here! Player 1, click 'Start Game' to begin.";
                        nextQuestionButton.style.display = 'block'; // Make it visible for Player 1
                        nextQuestionButton.textContent = "Start Game";
                        nextQuestionButton.disabled = false;
                    } else if (isPlayer2 && gameData.player2Id) {
                        questionDisplay.textContent = "Waiting for Player 1 to start the game...";
                        nextQuestionButton.style.display = 'none'; // Hide it for Player 2
                    }
                    break;

                case 'question':
                    questionDisplay.textContent = gameData.currentQuestion;
                    answerInputSection.style.display = 'block';
                    revealedAnswers.style.display = 'none';
                    nextQuestionButton.style.display = 'none'; // Hide next question button during answering phase

                    // Determine if current user has answered
                    const myAnswer = isPlayer1 ? gameData.player1Answer : gameData.player2Answer;
                    const otherPlayerAnswer = isPlayer1 ? gameData.player2Answer : gameData.player1Answer;
                    const otherPlayerName = isPlayer1 ? (gameData.player2Name || 'Player 2') : (gameData.player1Name || 'Player 1');

                    if (myAnswer) {
                        submitAnswerButton.disabled = true;
                        answerInput.value = myAnswer;
                        answerInput.readOnly = true;
                        // Show message if waiting for other player
                        if (!otherPlayerAnswer) {
                            showMessage(`You have submitted your answer. Waiting for ${otherPlayerName} to answer.`, 'info');
                        } else {
                            // Both have answered, state transition will handle this
                            showMessage("Both players have answered. Player 1 can reveal.", 'info');
                        }
                    } else {
                        submitAnswerButton.disabled = false;
                        answerInput.value = '';
                        answerInput.readOnly = false;
                        showMessage("Please submit your answer.", 'info'); // Prompt to answer
                    }

                    // If both players have answered, transition to 'revealing' state
                    if (gameData.player1Answer && gameData.player2Answer) {
                        if (isPlayer1) { // Only player 1 updates state to avoid race conditions
                            updateDoc(doc(db, `artifacts/${appId}/public/data/coupleGames`, gameId), {
                                state: 'revealing'
                            }).catch(e => console.error("Error updating state to revealing:", e));
                        }
                    }
                    break;

                case 'revealing':
                    questionDisplay.textContent = gameData.currentQuestion;
                    answerInputSection.style.display = 'none';
                    revealedAnswers.style.display = 'block'; // Show revealed answers
                    nextQuestionButton.style.display = 'block'; // Show next question button for Player 1
                    nextQuestionButton.textContent = "Next Question";

                    player1AnswerDisplay.innerHTML = `<strong>${gameData.player1Name || 'Player 1'}'s Answer:</strong> ${gameData.player1Answer || 'No answer'}`;
                    player2AnswerDisplay.innerHTML = `<strong>${gameData.player2Name || 'Player 2'}'s Answer:</strong> ${gameData.player2Answer || 'No answer'}`;

                    // Only player 1 can advance to the next question
                    nextQuestionButton.disabled = !isPlayer1;
                    if (!isPlayer1) {
                        showMessage("Waiting for Player 1 to advance to the next question.", 'info');
                    }
                    break;

                case 'finished':
                    gamePlayArea.style.display = 'none';
                    gameOverScreen.style.display = 'flex'; // Show game over screen
                    finalScoresDisplay.innerHTML = `Final Score: <br/><strong>${gameData.player1Name || 'Player 1'}</strong>: ${gameData.player1Score} <br/><strong>${gameData.player2Name || 'Player 2'}</strong>: ${gameData.player2Score}`;
                    showMessage("Game Over! Click 'Play Again' to start a new game.", 'info', true); // Persistent message
                    
                    // Trigger confetti effect
                    emitConfetti(confettiCanvas.width / 2, confettiCanvas.height / 2, 100);
                    break;
            }
        }

        /**
         * Creates a new game room.
         */
        async function createGame() {
            if (!userId) {
                showMessage("Please log in first.", 'error');
                return;
            }
            showLoading(true, 'Creating game...');
            try {
                gameId = userId; // Use creator's UID as game ID for simplicity
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/coupleGames`, gameId);
                const gameDocSnap = await getDoc(gameDocRef);

                if (gameDocSnap.exists()) {
                    showMessage("A game with your ID already exists. Joining it.", 'info');
                    await joinGame(gameId); // Try to join if it exists
                    return;
                }

                // Reset question count for a new game
                currentQuestionCount = 0;

                await setDoc(gameDocRef, {
                    player1Id: userId,
                    player1Name: playerName,
                    player2Id: null,
                    player2Name: null,
                    currentQuestion: '',
                    player1Answer: '',
                    player2Answer: '',
                    player1Score: 0,
                    player2Score: 0,
                    state: 'waiting', // waiting, question, revealing, finished
                    lastUpdated: new Date().toISOString(),
                    questionCount: 0 // Initialize question count in Firestore
                });
                showMessage("Game created! Share your User ID with your partner.", 'success');
                myUserIdSpan.textContent = userId;
                setupGameListener(gameId);
                showLoading(false);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Failed to create game. Please try again.", 'error');
                showLoading(false);
            }
        }

        /**
         * Joins an existing game room.
         * @param {string} id - The ID of the game to join.
         */
        async function joinGame(id) {
            if (!userId) {
                showMessage("Please log in first.", 'error');
                return;
            }
            if (!id) {
                showMessage("Please enter a game ID to join.", 'error');
                return;
            }
            showLoading(true, 'Joining game...');
            try {
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/coupleGames`, id);
                const gameDocSnap = await getDoc(gameDocRef);

                if (!gameDocSnap.exists()) {
                    showMessage("Game not found. Please check the ID.", 'error');
                    showLoading(false);
                    return;
                }

                const gameData = gameDocSnap.data();

                if (gameData.player1Id === userId || gameData.player2Id === userId) {
                    gameId = id;
                    showMessage("You are already in this game.", 'info');
                    setupGameListener(gameId);
                    showLoading(false);
                    return;
                }

                if (gameData.player2Id && gameData.player2Id !== userId) {
                    showMessage("This game already has two players.", 'error');
                    showLoading(false);
                    return;
                }

                // If player2Id is null, join as player 2
                await updateDoc(gameDocRef, {
                    player2Id: userId,
                    player2Name: playerName,
                    lastUpdated: new Date().toISOString()
                });
                gameId = id;
                showMessage("Joined game successfully!", 'success');
                myUserIdSpan.textContent = userId;
                setupGameListener(gameId);
                showLoading(false);
            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Failed to join game. Please try again.", 'error');
                showLoading(false);
            }
        }

        /**
         * Submits the current player's answer.
         */
        async function submitAnswer() {
            if (!gameId || !userId) {
                showMessage("Not in a game or not logged in.", 'error');
                return;
            }
            const answer = answerInput.value.trim();
            if (!answer) {
                showMessage("Please enter an answer.", 'info');
                return;
            }

            showLoading(true, 'Submitting answer...');
            try {
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/coupleGames`, gameId);
                const gameDocSnap = await getDoc(gameDocRef);
                if (!gameDocSnap.exists()) {
                    showMessage("Game not found.", 'error');
                    showLoading(false);
                    return;
                }
                const gameData = gameDocSnap.data();

                let updateData = {};
                if (userId === gameData.player1Id) {
                    updateData.player1Answer = answer;
                } else if (userId === gameData.player2Id) {
                    updateData.player2Answer = answer;
                } else {
                    showMessage("You are not a player in this game.", 'error');
                    showLoading(false);
                    return;
                }

                await updateDoc(gameDocRef, updateData);
                answerInput.value = ''; // Clear input after submission
                answerInput.readOnly = true;
                submitAnswerButton.disabled = true;
                showMessage("Answer submitted!", 'success');
                showLoading(false);
            } catch (error) {
                console.error("Error submitting answer:", error);
                showMessage("Failed to submit answer. Please try again.", 'error');
                showLoading(false);
            }
        }

        /**
         * Advances the game to the next question or ends it.
         * Only Player 1 can trigger this.
         */
        async function nextQuestion() {
            if (!gameId || !userId) {
                showMessage("Not in a game or not logged in.", 'error');
                return;
            }

            showLoading(true, 'Advancing game...');
            try {
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/coupleGames`, gameId);
                const gameDocSnap = await getDoc(gameDocRef);
                if (!gameDocSnap.exists()) {
                    showMessage("Game not found.", 'error');
                    showLoading(false);
                    return;
                }
                const gameData = gameDocSnap.data();

                // Only player 1 can advance
                if (userId !== gameData.player1Id) {
                    showMessage("Only Player 1 can advance the game.", 'error');
                    showLoading(false);
                    return;
                }

                // If currently revealing, calculate scores and prepare for next question
                if (gameData.state === 'revealing') {
                    let newPlayer1Score = gameData.player1Score || 0;
                    let newPlayer2Score = gameData.player2Score || 0;

                    if (gameData.player1Answer) {
                        newPlayer1Score++;
                    }
                    if (gameData.player2Answer) {
                        newPlayer2Score++;
                    }

                    // Increment question count
                    currentQuestionCount = (gameData.questionCount || 0) + 1;

                    // Check if all questions have been asked
                    if (currentQuestionCount >= maxQuestions) {
                        await updateDoc(gameDocRef, {
                            player1Score: newPlayer1Score,
                            player2Score: newPlayer2Score,
                            state: 'finished', // Transition to finished state
                            lastUpdated: new Date().toISOString(),
                            questionCount: currentQuestionCount // Update count
                        });
                        showMessage("Game is ending!", 'info');
                    } else {
                        const newQuestion = await generateTriviaQuestion(); // Get next dynamic question
                        await updateDoc(gameDocRef, {
                            player1Score: newPlayer1Score,
                            player2Score: newPlayer2Score,
                            currentQuestion: newQuestion,
                            player1Answer: '', // Clear previous answers
                            player2Answer: '',
                            state: 'question',
                            lastUpdated: new Date().toISOString(),
                            questionCount: currentQuestionCount // Update count
                        });
                        showMessage("Next question!", 'success');
                    }
                } else if (gameData.state === 'waiting' && gameData.player2Id) {
                    // Initial start of the game by Player 1
                    currentQuestionCount = 1; // Start first question
                    const initialQuestion = await generateTriviaQuestion(); // Get first dynamic question
                    await updateDoc(gameDocRef, {
                        currentQuestion: initialQuestion,
                        state: 'question',
                        lastUpdated: new Date().toISOString(),
                        questionCount: currentQuestionCount // Initialize count
                    });
                    showMessage("Game started!", 'success');
                } else {
                    showMessage("Game is not in a state to advance.", 'info');
                }
                showLoading(false);
            } catch (error) {
                console.error("Error advancing game:", error);
                showMessage("Failed to advance game. Please try again.", 'error');
                showLoading(false);
            }
        }

        /**
         * Leaves the current game.
         */
        async function leaveGame() {
            if (!gameId || !userId) {
                showMessage("Not in a game.", 'info');
                resetUI();
                return;
            }

            showLoading(true, 'Leaving game...');
            try {
                if (unsubscribeGameListener) {
                    unsubscribeGameListener(); // Stop listening
                    unsubscribeGameListener = null;
                }

                const gameDocRef = doc(db, `artifacts/${appId}/public/data/coupleGames`, gameId);
                const gameDocSnap = await getDoc(gameDocRef);

                if (gameDocSnap.exists()) {
                    const gameData = gameDocSnap.data();
                    if (gameData.player1Id === userId) {
                        // If player 1 leaves, delete the game room
                        await deleteDoc(gameDocRef);
                        showMessage("Game room deleted as you were Player 1.", 'info');
                    } else if (gameData.player2Id === userId) {
                        // If player 2 leaves, clear their slot
                        await updateDoc(gameDocRef, {
                            player2Id: null,
                            player2Name: null,
                            lastUpdated: new Date().toISOString(),
                            state: 'waiting' // Revert to waiting for a new player
                        });
                        showMessage("You have left the game.", 'info');
                    }
                }
                gameId = null;
                resetUI();
                showLoading(false);
            } catch (error) {
                console.error("Error leaving game:", error);
                showMessage("Failed to leave game gracefully. You might need to refresh.", 'error');
                resetUI();
                showLoading(false);
            }
        }

        /**
         * Resets the UI to the initial state (auth section).
         * This also resets all game state variables.
         */
        function resetUI() {
            authSection.style.display = 'block';
            gameLobby.style.display = 'none';
            gamePlayArea.style.display = 'none';
            gameOverScreen.style.display = 'none'; // Hide game over screen
            playerNameInput.value = playerName; // Keep last entered name
            joinGameIdInput.value = '';
            answerInput.value = '';
            answerInput.readOnly = false;
            submitAnswerButton.disabled = false;
            revealedAnswers.style.display = 'none';
            nextQuestionButton.style.display = 'none';
            player1ScoreDisplay.textContent = '0';
            player2ScoreDisplay.textContent = '0';
            player1NameDisplay.textContent = 'Player 1';
            player2NameDisplay.textContent = 'Player 2';
            questionDisplay.textContent = 'Waiting for game to start...';
            myUserIdSpan.textContent = userId || 'N/A';
            gameStatusSpan.textContent = 'Ready to play!';
            showMessage("", 'info'); // Clear any lingering messages
            currentQuestionCount = 0; // Reset question count for new game
            gameId = null; // Clear game ID
            if (unsubscribeGameListener) {
                unsubscribeGameListener(); // Ensure listener is stopped
                unsubscribeGameListener = null;
            }
            confettiParticles = []; // Clear confetti
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height); // Clear canvas
        }

        // Event Listeners
        startGameButton.addEventListener('click', () => {
            const name = playerNameInput.value.trim();
            if (name) {
                playerName = name;
                authSection.style.display = 'none';
                gameLobby.style.display = 'block';
                myUserIdSpan.textContent = userId; // Ensure it's updated
            } else {
                showMessage("Please enter your name.", 'info');
            }
        });

        createGameButton.addEventListener('click', createGame);
        joinGameButton.addEventListener('click', () => joinGame(joinGameIdInput.value.trim()));
        submitAnswerButton.addEventListener('click', submitAnswer);
        nextQuestionButton.addEventListener('click', nextQuestion);
        leaveGameButton.addEventListener('click', leaveGame);
        playAgainButton.addEventListener('click', resetUI); // New event listener for Play Again

        // Initialize Firebase and Confetti when the window loads
        window.onload = () => {
            initializeFirebase();
            resizeConfettiCanvas(); // Set initial canvas size
            animateConfetti(); // Start confetti animation loop
        };
        window.addEventListener('resize', resizeConfettiCanvas); // Resize confetti canvas on window resize
    </script>
</body>
</html>

